name: Check and Update Manifests

on:
  schedule:
    # Run daily at 5 AM UTC
    - cron: 0 5 * * *
  workflow_dispatch:
    inputs:
      app_filter:
        type: string
        required: false
        description: 'Optional: Specific app to check (leave empty for all)'

# Prevent multiple update runs
concurrency:
  group: update-manifests
  cancel-in-progress: false

jobs:
  get-apps:
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.get-apps.outputs.apps }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      
      - name: Get application directories
        id: get-apps
        run: |
          if [ -n "${{ github.event.inputs.app_filter }}" ]; then
            # Single app specified
            apps='["${{ github.event.inputs.app_filter }}"]'
          else
            # Get all app directories and create JSON array
            if [ -d "apps" ] && [ "$(ls -A apps/)" ]; then
              # Create JSON array on single line without newlines
              apps=$(find apps -maxdepth 1 -mindepth 1 -type d -exec basename {} \; | \
                     jq -R . | jq -s . | tr -d '\n')
            else
              apps='[]'
            fi
            # Handle empty array - GitHub Actions can't use empty arrays in matrix
            if [ "$apps" = "[]" ] || [ -z "$apps" ]; then
              echo "No apps found, exiting"
              exit 0
            fi
          fi
          echo "Found apps: $apps"
          # Output on single line without quotes
          echo "apps=$apps" >> $GITHUB_OUTPUT

  check-updates:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      
    strategy:
      matrix:
        app: ${{ fromJson(needs.get-apps.outputs.apps) }}
      max-parallel: 1
      fail-fast: false
            
    needs: get-apps
    if: needs.get-apps.outputs.apps != ''
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          fetch-tags: true

      - name: Check for manifest file
        id: manifest
        working-directory: apps/${{ matrix.app }}
        run: |
          echo "Checking ${{ matrix.app }} manifest..."
          # Find manifest file (could be .yml, .yaml, or .json)
          MANIFEST=$(find . -maxdepth 1 -type f \( -name "*.yml" -o -name "*.yaml" -o -name "*.json" \) | head -n1)
          if [ -z "$MANIFEST" ]; then
            echo "No manifest found in apps/${{ matrix.app }}"
            echo "has_manifest=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Found manifest: $MANIFEST"
          echo "manifest_file=$MANIFEST" >> $GITHUB_OUTPUT
          echo "has_manifest=true" >> $GITHUB_OUTPUT

      - name: "Update manifest if there are any updates"
        if: steps.manifest.outputs.has_manifest == 'true'
        uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest
        with:
            args: --edit-only "apps/${{ matrix.app }}/${{ steps.manifest.outputs.manifest_file }}"

      - name: Get app version from manifest
        id: get-version
        if: steps.manifest.outputs.has_manifest == 'true'
        working-directory: apps/${{ matrix.app }}
        run: |
          MANIFEST="${{ steps.manifest.outputs.manifest_file }}"
          SOURCE_VERSION=$(yq e '.modules[].sources[] | select(.["x-checker-data"]["is-main-source"] == true) | .tag // .["x-checker-data"].version // .url' "$MANIFEST" 2>/dev/null)
          VERSION=$(echo "$SOURCE_VERSION" | grep -oP 'v?([0-9]+\.[0-9]+\.[0-9]+(?:\.[0-9]+)?(?:[-+][0-9A-Za-z.]+)?)(?=\/|[-_.]|\.(?:tar|zip|gz|xz|bz2|deb)|$)' | head -n1)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          TAG="${{ matrix.app }}-$VERSION"
          DEPLOY_TAG="deploy-${{ matrix.app }}-${VERSION}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT

      - name: Check for version update
        id: check-updates
        if: steps.manifest.outputs.has_manifest == 'true'
        run: |
          TAG="${{ steps.get-version.outputs.tag }}"
          if git rev-parse "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Version tag $TAG already exists"
            echo "has_updates=false" >> $GITHUB_OUTPUT
          else
            echo "Version tag $TAG not found"
            echo "has_updates=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit manifest updates
        if: steps.check-updates.outputs.has_updates == 'true'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add apps/${{ matrix.app }}
          git commit -m "Update ${{ matrix.app }} to version ${{ steps.get-version.outputs.version }}"
          # Create version tag
          TAG="${{ steps.get-version.outputs.tag }}"
          git tag -a "$TAG" -m "Release ${{ matrix.app }} version ${{ steps.get-version.outputs.version }}"
          git push origin main
          git push origin "$TAG"
      
      - name: Check for deployment tag
        id: check-deploy
        if: steps.check-updates.outputs.has_updates == 'false'
        run: |
          VERSION="${{ steps.get-version.outputs.version }}"
          DEPLOY_TAG="${{ steps.get-version.outputs.deploy_tag }}"
          if git rev-parse "refs/tags/$DEPLOY_TAG" >/dev/null 2>&1; then
            echo "Deployment tag $DEPLOY_TAG already exists"
            echo "needs_build=false" >> $GITHUB_OUTPUT
          else
            echo "Deployment tag $DEPLOY_TAG not found"
            echo "needs_build=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Dispatch build workflow
        if: steps.check-updates.outputs.has_updates == 'true' || steps.check-deploy.outputs.needs_build == 'true'
        continue-on-error: true
        uses: ./.github/workflows/build.yml
        with:
          app: ${{ matrix.app }}
          ref: ${{ steps.get-version.outputs.tag }}
          deploy_tag: ${{ steps.get-version.outputs.deploy_tag }}
